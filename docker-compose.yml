# ============================================================
# Docker Compose - Acrobaticz Elite Production Stack
# Multi-service configuration with PostgreSQL, MinIO, and Next.js
# 
# SIMPLIFIED DEPLOYMENT FLOW:
# 1. Local: npm install && npm run build
# 2. Git: git commit && git push
# 3. Server: git clone && docker compose up
# 
# No build happens in Docker containers - pre-built artifacts only
# Ultra-portable: Works on any server with Docker installed
# 
# Usage on server:
#   git clone <repo>
#   cd <project>
#   docker-compose up -d
# 
# Configuration:
#   1. Copy .env.example to .env
#   2. Update DATABASE_URL, JWT_SECRET, S3 credentials
#   3. Run: docker-compose up -d
# ============================================================
# ============================================================

version: '3.9'

services:
  # ============================================================
  # PostgreSQL 16 Database (Primary Datastore)
  # Purpose: Persistent data storage for all application entities
  # Health: Required for app startup (depends_on: service_healthy)
  # 
  # Platform Support:
  # - linux/amd64 ✅ (x86-64 servers: AWS, DigitalOcean, etc.)
  # - linux/arm64 ✅ (ARM servers: AWS Graviton, Apple Silicon in Docker)
  # - linux/arm/v7 ✅ (Raspberry Pi, older ARM boards)
  # ============================================================
  postgres:
    image: postgres:16-alpine
    container_name: acrobaticz-postgres
    restart: unless-stopped
    pull_policy: if_not_present
    
    # Environment: Database credentials from .env
    # Must match DATABASE_URL construction in app service
    environment:
      POSTGRES_DB: ${DB_NAME:-acrobaticz}
      POSTGRES_USER: ${DB_USER:-acrobaticz_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me_strong_password_123}
      # PostgreSQL tuning parameters - adaptive for different hardware
      POSTGRES_INITDB_ARGS: >
        -c shared_buffers=256MB
        -c max_connections=100
        -c log_statement=none
        -c log_replication_commands=off
        -c maintenance_work_mem=64MB
      # High availability: Enable WAL archiving if needed
      POSTGRES_HOST_AUTH_METHOD: md5
    
    # Persistent storage for database files
    # Uses named volumes for portability across systems
    # Path is platform-independent and auto-created
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Optional: Custom initialization scripts
      # - ./scripts/database/init.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
    
    # Robust health check with extended timing for ARM systems
    # Validates: PostgreSQL is accepting connections
    # Timing: 20s startup grace (slow systems) → 15s intervals → 8s timeout → 5 retries max
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-acrobaticz_user} -d ${DB_NAME:-acrobaticz} -t 5"]
      interval: 15s
      timeout: 8s
      retries: 5
      start_period: 20s
    
    networks:
      - acrobaticz-network
    
    # Resource constraints - adaptive for different server sizes
    # Adjust these based on your infrastructure
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M
    
    # Logging configuration - JSON format for log aggregation
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=postgres,environment=production"

  # ============================================================
  # MinIO S3-Compatible Object Storage
  # Purpose: File/binary data storage with S3 API compatibility
  # Access: S3 API (internal): http://minio:9000 (port 9000)
  #         Web Console (dev):  http://localhost:9001 (port 9001)
  # 
  # Storage Configuration:
  # - Local (default):     ./storage/minio
  # - External disk:       Set STORAGE_PATH=/path/to/disk in .env
  # - NAS/Network paths:   STORAGE_PATH=/mnt/nas/acrobaticz-storage
  # - Cloud storage:       Integrate with MinIO S3 gateway mode
  # 
  # Platform Support: ✅ All platforms (amd64, arm64, arm/v7)
  # ============================================================
  minio:
    image: minio/minio:latest
    container_name: acrobaticz-minio
    restart: unless-stopped
    pull_policy: if_not_present
    
    # Root credentials for MinIO admin panel
    # IMPORTANT: Change in .env for production!
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin_change_me_123}
      # Platform detection for optimal performance
      MINIO_SERVER_URL: ${MINIO_SERVER_URL:-http://localhost:9000}
      MINIO_BROWSER_REDIRECT_URL: ${MINIO_BROWSER_URL:-http://localhost:9001}
      # High availability options (optional)
      # MINIO_DOMAIN: minio.yourdomain.com
    
    # Volume mapping: Local or external disk
    # STORAGE_PATH variable allows external disk mounting
    # Docker automatically creates named volume on first run
    volumes:
      # Map to external disk: set STORAGE_PATH=/path/to/external/disk in .env
      # Default: ./storage/minio (relative to docker-compose location)
      - ${STORAGE_PATH:-./storage/minio}:/minio/data
    
    # Start MinIO in server mode with console on :9001
    # Works on all architectures automatically
    command: server /minio/data --console-address :9001
    
    # Expose ports
    ports:
      # 9000: MinIO S3 API (internal + external access)
      - "9000:9000"
      # 9001: MinIO Web Console (comment out for production)
      - "9001:9001"
    
    # Robust health check with extended timing
    # Validates: MinIO S3 API is responding to health probes
    # Extended timeout for slow systems and network I/O
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 20s
      timeout: 10s
      retries: 5
      start_period: 30s
    
    networks:
      - acrobaticz-network
    
    # Resource constraints - optimized for storage workloads
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M
    
    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=minio,environment=production"
      options:
        max-size: "10m"
        max-file: "3"

  # ============================================================
  # Acrobaticz Application (Next.js 15 - Pre-built)
  # Purpose: Main application server with pre-built artifacts
  # Build: Uses pre-built .next/ from npm run build (local)
  # Dependencies: PostgreSQL (healthy) + MinIO (healthy)
  # Platform Support: ✅ Multi-arch (amd64, arm64, arm/v7)
  # ============================================================
  app:
    build:
      context: .
      dockerfile: Dockerfile
      # No build args - uses pre-built artifacts only
    
    image: acrobaticz:latest
    container_name: acrobaticz-app
    restart: unless-stopped
    pull_policy: if_not_present
    
    # Environment configuration - SYNCHRONIZED WITH .env.example
    # All variables loaded from .env file at startup
    environment:
      # ============================================================
      # Next.js Core Configuration
      # ============================================================
      NODE_ENV: ${NODE_ENV:-production}
      PORT: ${PORT:-3000}
      HOSTNAME: 0.0.0.0
      NEXT_TELEMETRY_DISABLED: 1
      NODE_OPTIONS: "--max_old_space_size=2048 --disable-warning=DEP0040"
      
      # ============================================================
      # Database Configuration (PostgreSQL)
      # URL format: postgresql://user:password@host:port/dbname?schema=public
      # Components from .env:
      #   - DB_USER: Database user (default: acrobaticz_user)
      #   - DB_PASSWORD: User password (MUST change in production)
      #   - DB_NAME: Database name (default: acrobaticz)
      # Service name "postgres" resolves to container IP via Docker DNS
      # ============================================================
      DATABASE_URL: postgresql://${DB_USER:-acrobaticz_user}:${DB_PASSWORD:-change_me_strong_password_123}@postgres:5432/${DB_NAME:-acrobaticz}?schema=public&connect_timeout=10&application_name=acrobaticz
      
      # ============================================================
      # JWT Authentication (JSON Web Tokens)
      # JWT_SECRET: Signing key for token generation/validation
      # Generate secure secret: openssl rand -base64 32
      # WARNING: MUST change in production!
      # ============================================================
      JWT_SECRET: ${JWT_SECRET:-please_change_this_secret_key_in_production_123}
      JWT_EXPIRATION: ${JWT_EXPIRATION:-7d}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY:-please_change_this_encryption_key_in_production}
      
      # ============================================================
      # MinIO/S3 Configuration
      # S3_ENDPOINT: Internal DNS name (minio:9000) or external URL
      # S3_ACCESS_KEY: MinIO root user (from MINIO_ROOT_USER)
      # S3_SECRET_KEY: MinIO root password (from MINIO_ROOT_PASSWORD)
      # S3_BUCKET: Default bucket for uploads (must be created by app)
      # S3_REGION: AWS region identifier (minio uses us-east-1 default)
      # ============================================================
      MINIO_ENDPOINT: ${MINIO_ENDPOINT:-http://minio:9000}
      S3_ENDPOINT: ${S3_ENDPOINT:-http://minio:9000}
      S3_ACCESS_KEY: ${S3_ACCESS_KEY:-minioadmin}
      S3_SECRET_KEY: ${S3_SECRET_KEY:-minioadmin_change_me_123}
      S3_BUCKET: ${S3_BUCKET:-acrobaticz}
      S3_REGION: ${S3_REGION:-us-east-1}
      S3_USE_PATH_STYLE: ${S3_USE_PATH_STYLE:-true}
      
      # ============================================================
      # Optional: Third-party API Integration
      # ============================================================
      DEEPL_API_KEY: ${DEEPL_API_KEY:-}
      
      # ============================================================
      # Optional: Custom Domain
      # Used for email links, redirects, CORS configuration
      # ============================================================
      DOMAIN: ${DOMAIN:-localhost:3000}
      NEXTAUTH_URL: ${NEXTAUTH_URL:-http://localhost:3000}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-${JWT_SECRET}}
      
      # ============================================================
      # Performance & Optimization
      # ============================================================
      # Increase for slow network connections
      DB_POOL_SIZE: ${DB_POOL_SIZE:-10}
      DB_TIMEOUT: ${DB_TIMEOUT:-30000}
    
    # Persistent volumes for application data
    volumes:
      # Application storage (local uploads directory)
      # Fallback if S3/MinIO is unavailable
      - app_storage:/app/public/uploads
      # Cache directory (improves startup speed)
      - app_cache:/app/.next/cache
      # Temporary files
      - app_tmp:/app/tmp
    
    # Service dependencies: Wait for healthy services before starting app
    # condition: service_healthy ensures dependencies are fully initialized
    depends_on:
      postgres:
        condition: service_healthy
      minio:
        condition: service_healthy
    
    # Port mapping: Container port 3000 → Host port (from .env PORT)
    ports:
      - "${PORT:-3000}:3000"
    
    # Robust health check - tuned for production and slow systems
    # Endpoint: /api/health (must return 200 OK)
    # Extended timing for initial DB connections
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:3000/api/health"]
      interval: 45s
      timeout: 15s
      retries: 3
      start_period: 120s
    
    networks:
      - acrobaticz-network
    
    # Resource constraints - balanced for production
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1.5G
        reservations:
          cpus: '1'
          memory: 1G
    
    # Logging configuration - comprehensive for production debugging
    logging:
      driver: "json-file"
      options:
        max-size: "15m"
        max-file: "5"
        labels: "service=app,environment=production"

  # ============================================================
  # DuckDNS Dynamic DNS Service
  # Purpose: Automatically updates domain IP address for dynamic IPs
  # Features: HTTPS support, automatic renewal, no setup needed
  # 
  # Configuration:
  #   DUCKDNS_DOMAIN: Your DuckDNS domain (ex: "mydomain" for mydomain.duckdns.org)
  #   DUCKDNS_TOKEN: Your DuckDNS token from https://www.duckdns.org
  # 
  # Platform Support: ✅ All platforms (amd64, arm64, arm/v7)
  # ============================================================
  duckdns:
    image: linuxserver/duckdns:latest
    container_name: acrobaticz-duckdns
    restart: unless-stopped
    pull_policy: if_not_present
    
    # Environment configuration
    environment:
      # DuckDNS subdomain (MUST match your domain from duckdns.org)
      # Example: if domain is "myapp.duckdns.org", set SUBDOMAINS=myapp
      SUBDOMAINS: ${DUCKDNS_DOMAIN:-acrobaticz}
      
      # DuckDNS API token (generate at https://www.duckdns.org)
      TOKEN: ${DUCKDNS_TOKEN:-}
      
      # Update interval (in seconds) - how often to check/update IP
      # Default: 300 seconds (5 minutes)
      # Set lower for dynamic environments, higher for stable IPs
      INTERVAL: ${DUCKDNS_INTERVAL:-300}
      
      # IPv6 support (optional - enable if IPv6 is available)
      # IPV6: ${DUCKDNS_IPV6:-false}
      
      # Log to file (for debugging)
      LOG_FILE: ${DUCKDNS_LOG_FILE:-true}
      
      # Enable HTTPS certificate generation (automatic with Let's Encrypt)
      # PUID/PGID for proper file permissions
      PUID: 1000
      PGID: 1000
    
    # Persistent storage for logs
    volumes:
      # Config directory - stores logs and certificate info
      - duckdns_config:/config
    
    # Networks
    networks:
      - acrobaticz-network
    
    # Resource constraints (minimal - just DNS updates)
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: 64M
        reservations:
          memory: 32M
    
    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"
        labels: "service=duckdns,environment=production"

  # ============================================================
  # Nginx Reverse Proxy (Optional - for SSL/TLS and Load Balancing)
  # Purpose: TLS termination, static file serving, request routing
  # Enable: Uncomment this section and configure SSL certificates
  # Ports: 80 (HTTP) → 3000 (app), 443 (HTTPS) → 3000 (app)
  # ============================================================
  nginx:
    image: nginx:alpine
    container_name: acrobaticz-nginx
    restart: unless-stopped
    
    # Ports (80: HTTP, 443: HTTPS)
    ports:
      - "80:80"
      - "443:443"
    
    # Configuration and certificates
    volumes:
      # Nginx configuration
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      # SSL certificates (create if using HTTPS)
      - nginx_certs:/etc/nginx/certs:ro
      # Static files
      - ./public:/usr/share/nginx/html/static:ro
    
    # Environment
    environment:
      - DOMAIN=${DOMAIN:-localhost}
    
    # Wait for app to be healthy before starting nginx
    depends_on:
      app:
        condition: service_healthy
    
    networks:
      - acrobaticz-network
    
    # Health check
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:80/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    
    # Resource constraints
    deploy:
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M
    
    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

# ============================================================
# Volumes (Persistent Data Storage)
# 
# Docker volumes provide data persistence across container restarts
# Named volumes are portable across different Docker hosts
# Each volume is platform-independent and works on all architectures
# ============================================================
volumes:
  # PostgreSQL Data
  # Purpose: Database files, indexes, WAL logs
  # Size: Varies by application usage (starts ~100MB)
  # Backup: Regular backups recommended for production
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/data/postgres
  
  # MinIO Storage
  # Purpose: S3-compatible object storage
  # Managed via STORAGE_PATH environment variable
  # Can be local or external disk (NFS, EBS, etc.)
  # Size: Grows with uploaded files
  
  # Application Storage
  # Purpose: Local file uploads (redundant with MinIO)
  # Provides fallback if S3 unavailable
  app_storage:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/data/app_storage
  
  # Application Cache
  # Purpose: Next.js build cache for faster cold starts
  # Improves startup time significantly
  app_cache:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/data/app_cache
  
  # Application Temp
  # Purpose: Temporary files during processing
  # Improves disk I/O performance
  app_tmp:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/data/app_tmp
  
  # DuckDNS Configuration
  # Purpose: Stores DuckDNS logs and configuration
  # Data persists across container restarts
  duckdns_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/data/duckdns
  
  # Nginx SSL Certificates (if using nginx)
  # Purpose: TLS certificates for HTTPS
  # Note: Create ./certs directory and add cert files if using HTTPS
  nginx_certs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${PWD}/certs

# ============================================================
# Networks
# 
# Custom bridge network isolates containers from host network
# Provides predictable DNS resolution between services
# Enables inter-service communication on all platforms
# ============================================================
networks:
  acrobaticz-network:
    driver: bridge
    driver_opts:
      # Custom bridge name for easier debugging
      com.docker.network.bridge.name: br-acrobaticz
    ipam:
      # Fixed subnet for predictable IP assignments
      config:
        - subnet: 172.30.0.0/16
